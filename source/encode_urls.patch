diff -u -r aws-gpl-2018-src-orig/src/core/aws-client.adb aws-gpl-2018-src/src/core/aws-client.adb
--- aws-gpl-2018-src-orig/src/core/aws-client.adb	2018-05-23 00:03:23.000000000 -0500
+++ aws-gpl-2018-src/src/core/aws-client.adb	2018-06-13 15:36:36.980399500 -0500
@@ -155,7 +155,8 @@
    is
       use type Net.SSL.Config;
 
-      Host_URL    : constant AWS.URL.Object := AWS.URL.Parse (Host);
+      Host_URL    : constant AWS.URL.Object := AWS.URL.Parse
+        (Host, Decode => False);
       Proxy_URL   : constant AWS.URL.Object := AWS.URL.Parse (Proxy);
       Connect_URL : AWS.URL.Object;
    begin
diff -u -r aws-gpl-2018-src-orig/src/core/aws-url.adb aws-gpl-2018-src/src/core/aws-url.adb
--- aws-gpl-2018-src-orig/src/core/aws-url.adb	2018-05-23 00:03:23.000000000 -0500
+++ aws-gpl-2018-src/src/core/aws-url.adb	2018-06-13 15:36:36.351284800 -0500
@@ -123,10 +123,6 @@
             Res (K) := Character'Val (Utils.Hex_Value (Str (I + 1 .. I + 2)));
             I := I + 2;
 
-         elsif Str (I) = '+' then
-            --  A plus is used for spaces in forms value for example
-            Res (K) := ' ';
-
          else
             Res (K) := Str (I);
          end if;
@@ -319,13 +315,15 @@
    -----------
 
    function Parse
-      (URL            : String;
-       Check_Validity : Boolean := True;
-       Normalize      : Boolean := False) return Object
+     (URL            : String;
+      Check_Validity : Boolean := True;
+      Normalize      : Boolean := False;
+      Decode         : Boolean := True)
+     return Object
    is
       O : Object;
    begin
-      Set.Parse (O, URL, Check_Validity, Normalize);
+      Set.Parse (O, URL, Check_Validity, Normalize, Decode);
 
       return O;
    end Parse;
diff -u -r aws-gpl-2018-src-orig/src/core/aws-url.ads aws-gpl-2018-src/src/core/aws-url.ads
--- aws-gpl-2018-src-orig/src/core/aws-url.ads	2018-05-23 00:03:23.000000000 -0500
+++ aws-gpl-2018-src/src/core/aws-url.ads	2018-06-13 15:36:35.592476000 -0500
@@ -68,7 +68,9 @@
    function Parse
      (URL            : String;
       Check_Validity : Boolean := True;
-      Normalize      : Boolean := False) return Object;
+      Normalize      : Boolean := False;
+      Decode         : Boolean := True)
+     return Object;
    --  Parse an URL and return an Object representing this URL. It is then
    --  possible to extract each part of the URL with the services bellow.
    --  Raises URL_Error if Check_Validity is true and the URL reference a
diff -u -r aws-gpl-2018-src-orig/src/core/aws-url-set.adb aws-gpl-2018-src/src/core/aws-url-set.adb
--- aws-gpl-2018-src-orig/src/core/aws-url-set.adb	2018-05-23 00:03:23.000000000 -0500
+++ aws-gpl-2018-src/src/core/aws-url-set.adb	2018-06-13 15:49:11.390157900 -0500
@@ -156,9 +156,10 @@
 
    procedure Parse
      (Item           : in out Object;
-      URL            : String;
-      Check_Validity : Boolean := True;
-      Normalize      : Boolean := False)
+      URL            :        String;
+      Check_Validity :        Boolean := True;
+      Normalize      :        Boolean := False;
+      Decode         :        Boolean := True)
    is
       FTP_Token   : constant String := "ftp:";
       HTTP_Token  : constant String := "http:";
@@ -173,6 +174,8 @@
       function "+" (S : String) return Unbounded_String
          renames To_Unbounded_String;
 
+      function Maybe_Decode (Item : String) return String;
+
       procedure Parse (URL : String);
       --  Parse URL, the URL must not contain the HTTP_Token prefix.
       --  If a hostname is specified, the URL should start with "//"
@@ -181,6 +184,19 @@
       --  Parse the protocol part of the URL and return it. Return an empty
       --  string if not found.
 
+      ------------------
+      -- Maybe_Decode --
+      ------------------
+
+      function Maybe_Decode (Item : String) return String
+      is begin
+         if Decode then
+            return AWS.URL.Decode (Item);
+         else
+            return Item;
+         end if;
+      end Maybe_Decode;
+
       -----------
       -- Parse --
       -----------
@@ -214,7 +230,7 @@
                --  which must be part of the path.
 
                declare
-                  File : constant String := Decode (PF);
+                  File : constant String := Maybe_Decode (PF);
                begin
                   if File = ".." or else File = "." then
                      Item.Path := +File;
@@ -230,13 +246,14 @@
                --  parent directories which must be part of the path.
 
                declare
-                  File : constant String := Decode (URL (I3 + 1 .. URL'Last));
+                  File : constant String := Maybe_Decode
+                    (URL (I3 + 1 .. URL'Last));
                begin
                   if File = ".." or else File = "." then
-                     Item.Path := +Decode (PF);
+                     Item.Path := +Maybe_Decode (PF);
                      Item.File := +"";
                   else
-                     Item.Path := +Decode (URL (Start .. I3));
+                     Item.Path := +Maybe_Decode (URL (Start .. I3));
                      Item.File := +File;
                   end if;
                end;
@@ -419,7 +436,7 @@
          Item.Fragment := Null_Unbounded_String;
 
       else
-         Item.Fragment := +Decode (L_URL (F .. L_URL'Last));
+         Item.Fragment := +Maybe_Decode (L_URL (F .. L_URL'Last));
          F := F - 1;
       end if;
 
@@ -431,6 +448,7 @@
          P := F;
 
       else
+         --  Add looks for the rest of the '?', so we can't decode here.
          Item.Parameters.Add (L_URL (P .. F));
          P := P - 1;
       end if;
@@ -439,16 +457,16 @@
 
       if Utils.Match (L_URL (L_URL'First .. P), HTTP_Token) then
          Item.Port := Default_HTTP_Port;
-         Parse (L_URL (L_URL'First + HTTP_Token'Length .. P));
+         Parse (Maybe_Decode (L_URL (L_URL'First + HTTP_Token'Length .. P)));
 
       elsif Utils.Match (L_URL (L_URL'First .. P), HTTPS_Token) then
          Item.Port := Default_HTTPS_Port;
-         Parse (L_URL (L_URL'First + HTTPS_Token'Length .. P));
+         Parse (Maybe_Decode (L_URL (L_URL'First + HTTPS_Token'Length .. P)));
          Item.Protocol := HTTPS;
 
       elsif Utils.Match (L_URL (L_URL'First .. P), FTP_Token) then
          Item.Port := Default_FTP_Port;
-         Parse (L_URL (L_URL'First + FTP_Token'Length .. P));
+         Parse (Maybe_Decode (L_URL (L_URL'First + FTP_Token'Length .. P)));
          Item.Protocol := FTP;
 
       elsif P >= L_URL'First then
@@ -460,11 +478,12 @@
 
          if Scheme /= Null_Unbounded_String then
             Item.Protocol := Scheme;
-            Parse (L_URL (L_URL'First + Length (Scheme) + 1 .. P));
+            Parse
+              (Maybe_Decode (L_URL (L_URL'First + Length (Scheme) + 1 .. P)));
 
          else
             Item.Protocol := Null_Unbounded_String;
-            Parse (L_URL (L_URL'First .. P));
+            Parse (Maybe_Decode (L_URL (L_URL'First .. P)));
          end if;
 
       else
diff -u -r aws-gpl-2018-src-orig/src/core/aws-url-set.ads aws-gpl-2018-src/src/core/aws-url-set.ads
--- aws-gpl-2018-src-orig/src/core/aws-url-set.ads	2018-05-23 00:03:23.000000000 -0500
+++ aws-gpl-2018-src/src/core/aws-url-set.ads	2018-06-13 15:36:33.477241100 -0500
@@ -56,8 +56,9 @@
 
    procedure Parse
      (Item           : in out Object;
-      URL            : String;
-      Check_Validity : Boolean := True;
-      Normalize      : Boolean := False);
+      URL            :        String;
+      Check_Validity :        Boolean := True;
+      Normalize      :        Boolean := False;
+      Decode         :        Boolean := True);
 
 end AWS.URL.Set;
